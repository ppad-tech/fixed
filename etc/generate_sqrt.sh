#!/usr/bin/env bash

# generates a constant-time haskell function for performing modular
# square root with montgomery arithmetic on the secp256k1 field prime.
#
# tonelli-shanks is used. since p = 3 mod 4 for secp256k1, the square
# root simplifies to a single exponentiation:
#
# sqrt(a) = a ^ ((p + 1) / 4) mod p
#
# one proceeds through the (fixed, known) bit-string of the exponent
# in MSB order, montgomery-squaring an accumulator each time, and
# montgomery-multiplying on every '1' bit. this script generates a
# function consisting of this loop, unrolled.
#
# since the square-and-multiply schedule is fixed, then given
# constant-time 'sqr#' and 'mul#", 'sqrt#' is also constant-time by
# construction.

# for tonelli-shanks on secp256k1, p = 3 mod 4, so we compute:
#
# sqrt(a) = a ^ ((p + 1) / 4) mod p
#
# where p is the secp256k1 field prime:
#
# p = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F
#
# and the exponent (p + 1) / 4 is:
#
# e = 0x3fffffffffffffffffffffffffffffffffffffffffffffffffffffffbfffff0c

exponent="0011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110111111111111111111111100001100"

echo "-- generated by etc/generate_sqrt.sh"
echo "sqrt#"
echo "  :: (# Limb, Limb, Limb, Limb #)"
echo "  -> (# Limb, Limb, Limb, Limb #)"
echo "sqrt# a ="
echo "  let !t0 = (# Limb 0x1000003D1##, Limb 0##, Limb 0##, Limb 0## #)"

label=1

for ((i = 0; i < ${#exponent}; i++)); do
  echo "      !t""$label"" = sqr# t""$((label-1))"
  if [[ "${exponent:i:1}" == "1" ]]; then
    label=$((label+1))
    echo "      !t""$label"" = mul# a t""$((label-1))"
  fi
  label=$((label+1))
done

echo "      !r = t""$((label-1))"
echo "  in  r"
echo '{-# INLINE sqrt# #-}'
